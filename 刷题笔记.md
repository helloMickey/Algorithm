# 数据结构相关：
## 数组，链表


- 删除链表中的节点时，并不一定需要知道其 prev_p 指针，直接将其值和下一个节点进行交换，然后删除下一个节点即可。前提是所删除的节点不是末尾节点！！

- 通过**快慢双指针**，一个每次走一步，另一个每次走两布。可以**确定链表的中间节点**。 👉 [链表反转 + 快慢指针](lc-cn/回文链表.cpp) 示例。
  
  快慢指针也可用于**判断链表中是否存在环**，若存在环则 fast 与 slow 肯定会在若干步之后相遇，若要确定环的入口，slow 与 fast 相遇时我们再额外使用一个指针 ptr 它指向链表头部， 它和 slow 每次向后移动一个位置，最终它们会在入环点相遇 👉[环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)。

- 滑动窗口法：[和为s的连续正数序列](lc-cn/剑指offer/和为s的连续正数序列.cpp)
- `双向链表` 可以很方面的检索其前后节点，插入、删除时链表的链接都很便捷。
  
## 栈，队列
递归的过程过程本质上是一系列的函数栈调用，所有的递归过程都可以通过迭代来实现。

相关题目：
- 双栈实现队列；[双队列也可实现栈](https://assets.leetcode-cn.com/solution-static/225/225_fig1.gif)，[单个队列也可实现栈](https://assets.leetcode-cn.com/solution-static/225/225_fig2.gif)
- 字符串表达式计算：中缀表达式转后缀表达式（**逆波兰表达式**）。 [例1](lc-cn/基本计算器.cpp)， [例2](lc-cn/基本计算器2.cpp)， 符号栈是否进行弹出取决于，当前操作符与栈顶操作符优先谁高，栈顶优先级高或者相等则先进行出栈和计算（相同优先级别，从左到右计算， 所以也要弹出），直到栈顶元素优先机低于当前操作符

## 集合

## 哈希表
知识点：地址映射函数 + 冲突处理方法。

冲突处理方法：1）开地址发法；2）闭地址法 =》 拉链法
在C++ STL 中，冲突处理方法是？

## 树/二叉树
树的遍历：二叉树的先序、中序、后序、层次序遍历。因为树本身是一种特殊的图，因为深度、广度优先遍历的概念也存在。**二叉树的广度优先遍历 = 层次序遍历，先序遍历 = （每次先访问左子树的）深度优先遍历**。

`二叉搜索树（BST）`相关：二叉搜索树具备一些特殊的性质。

`完全二叉树`：每个节点都有左右两个子树，如果通过数组来存储完全二叉树，则每个节点的左右子节点可以通过快速计算下标获得。

`平衡二叉树`：检查二叉树是否平衡；二叉树平衡调整。

其他：
- 给定一个先序遍历结果，求可能的后续遍历结果的可能数 = catalan 数 = C(2n,n) / (n+1)。
假设n个节点存在二叉排序树的个数是G(n)，G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)

值得说的题目：
- **通过迭代实现树的遍历** 👉 [通过栈迭代实现中序遍历](lc-cn/二叉搜索树中第K小的元素.cpp) 。在二叉树的三种遍历中，通过栈实现的难度排序是：**后序 > 中序 > 前序**。
- 典型的层次序遍历代码写法 👉 [二叉树层次遍历示例](lc-cn/二叉树的右视图.cpp) 。
- [二叉搜索树中，两个节点的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)，因为是二叉搜索树，遍历找分叉节点。 **延伸题目**：[在普通二叉树中，找两个节点的公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)，通过 👉 [递归求解！](lc-cn/二叉树的最近公共祖先.cpp)
- 判断一个树是否是对称二叉树
- 给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 
- 二叉树的层次序遍历：借助队列实现
- 通过中序 + 后续重构一个二叉树；通过 中序 + 后续 重构一个二叉树；树中应该是不存在重复元素的 =》 转化为递归建树的过程
- 树的递归遍历十分简单，但是要会通过迭代的方式完成同样的操作。例如，题目：通过迭代实现树的先序遍历 =》通过栈完成
- 将二叉树叶子节点的 null 指针进行填充，使其能够快速达到某种访问目的 =》`线索二叉树`
- 判断一个二叉搜索树的后序遍历序列是否是合法的. => [二叉搜索树的后序遍历序列](lc-cn/剑指offer/二叉搜索树的后序遍历序列.cpp)

## 最大/最小堆
最大/最小堆是优先级队列的一种实现方法.
C++中的堆
相关题目：
- 数据流中的中位数


# 算法
## 递归
将问题划分为更小的子问题进行递归求解，把握住两点：1）子问题与原问题之间的关联；2）递归终止条件；
- [圆圈中最后剩下的数字](lc-cn/剑指offer/圆圈中最后剩下的数字.cpp)
## 搜索算法
**二分查找法**
## 排序算法
相关的题目：
- 排序的延伸，[把数组排成最小的数](lc-cn/剑指offer/把数组排成最小的数.cpp)
## 字符串相关
- 🚩字符串编辑距离
- 字符串匹配
## 图相关算法
深度优先DFS、广度优先BFS；一般深度优先遍历通过递归实现，广度优先遍历通过队列实现。
- 通过DFS构造排列组合 👉 [字符串排列](lc-cn/剑指offer/字符串的排列.cpp)

最小生成树；


最短路径；

## 贪心算法

## 分治算法


## 动态规划 💔💔

例题：
- [二叉树的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)， 通过 👉 [“递归式式的动态规划”](lc-cn/二叉树最大路径和.cpp) 求解。

# 其他
### 自动机
- 🚩 通过DFA（有限状态自动机）实现 [字符串转整数](https://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/)。

### 数学
- [两数相除](https://leetcode-cn.com/problems/divide-two-integers/)
- [巴什博奕](https://zhuanlan.zhihu.com/p/87826616)


### 位运算
C++中的位运算操作符： 带符号左右移：`<<` 、`>>`， 与或非： `&`、 `|` 、`!` ， 异或：`^`，取反：`~`

- C++中没有（java中有）无符号左右移： `<<<` 、`>>>`。在c++中实现的方式也很简单，先将拟进行无符号右移的数转换成无符号类型，然后执行普通右移即可。

- 异或操作具有的性质：
0 ^ x = x ，x ^ x = 0. a^b = c ， a^b^b = a， 即 c^b=a 同理 c^a =b.

参考题目：
- [数组中数字出现的次数](lc-cn/剑指offer/数组中数字出现的次数1.cpp)
- [数组中数字出现的次数2](lc-cn/剑指offer/数组中数字出现的次数2.cpp)
- [判断一个整数是否是2的幂](https://leetcode-cn.com/problems/power-of-two/solution/2de-mi-by-leetcode-solution-rny3/) ，如果 n 是正整数并且 n & (n - 1) = 0，那么 n 就是 2 的幂。如果 n 是正整数并且 n & (-n) = n，那么 n 就是 2 的幂